/**
 * YieldVaultClient - Contract interaction abstraction
 *
 * Centralizes all YieldVault contract calls with:
 * - Type-safe method signatures
 * - Automatic error handling and parsing
 * - Consistent return types
 * - Gas estimation (future enhancement)
 */

import type { PublicClient, WalletClient, Address, Hash } from 'viem'
import { YieldVaultABI } from '@/lib/contracts/abis'
import { getYieldVaultAddress } from '@/lib/contracts/addresses'
import { parseContractError } from '../errors'

/**
 * Strategy types supported by the vault
 */
export enum Strategy {
  Hold = 0,
  Conservative = 1,
  Aggressive = 2,
}

/**
 * Deposit parameters
 */
export interface DepositParams {
  tokenId: bigint
  principal: bigint
  strategy: Strategy
}

/**
 * Deposit data from contract
 */
export interface Deposit {
  principal: bigint
  strategy: Strategy
  startTime: bigint
  lastInteractionTime: bigint
  accruedYield: bigint
}

/**
 * YieldVault Contract Client
 *
 * Provides clean abstraction over YieldVault contract interactions.
 * Handles both read operations (via PublicClient) and write operations (via WalletClient).
 *
 * Example usage:
 * ```tsx
 * const client = new YieldVaultClient(chainId, publicClient, walletClient)
 *
 * // Read operations
 * const tvl = await client.getTotalValueLocked()
 * const deposit = await client.getDeposit(tokenId)
 *
 * // Write operations
 * const hash = await client.deposit({ tokenId, principal, strategy })
 * ```
 */
export class YieldVaultClient {
  private address: Address
  private publicClient: PublicClient
  private walletClient?: WalletClient

  constructor(
    chainId: number,
    publicClient: PublicClient,
    walletClient?: WalletClient
  ) {
    this.address = getYieldVaultAddress(chainId)
    this.publicClient = publicClient
    this.walletClient = walletClient
  }

  // ==================== Read Methods ====================

  /**
   * Get total value locked in the vault
   */
  async getTotalValueLocked(): Promise<bigint> {
    try {
      const result = await this.publicClient.readContract({
        address: this.address,
        abi: YieldVaultABI,
        functionName: 'totalValueLocked',
      })
      return result as bigint
    } catch (error) {
      throw parseContractError(error)
    }
  }

  /**
   * Get total yield generated by the vault
   */
  async getTotalYield(): Promise<bigint> {
    try {
      const result = await this.publicClient.readContract({
        address: this.address,
        abi: YieldVaultABI,
        functionName: 'totalYield',
      })
      return result as bigint
    } catch (error) {
      throw parseContractError(error)
    }
  }

  /**
   * Get total number of active deposits
   */
  async getTotalDeposits(): Promise<bigint> {
    try {
      const result = await this.publicClient.readContract({
        address: this.address,
        abi: YieldVaultABI,
        functionName: 'totalDeposits',
      })
      return result as bigint
    } catch (error) {
      throw parseContractError(error)
    }
  }

  /**
   * Get deposit details for a specific token
   */
  async getDeposit(tokenId: bigint): Promise<Deposit | null> {
    try {
      const result = await this.publicClient.readContract({
        address: this.address,
        abi: YieldVaultABI,
        functionName: 'deposits',
        args: [tokenId],
      })

      const deposit = result as [bigint, number, bigint, bigint, bigint]

      // Check if deposit exists (principal > 0)
      if (deposit[0] === 0n) {
        return null
      }

      return {
        principal: deposit[0],
        strategy: deposit[1] as Strategy,
        startTime: deposit[2],
        lastInteractionTime: deposit[3],
        accruedYield: deposit[4],
      }
    } catch (error) {
      throw parseContractError(error)
    }
  }

  /**
   * Get APY for a specific strategy
   */
  async getStrategyAPY(strategy: Strategy): Promise<bigint> {
    try {
      const result = await this.publicClient.readContract({
        address: this.address,
        abi: YieldVaultABI,
        functionName: 'getAPY',
        args: [strategy],
      })
      return result as bigint
    } catch (error) {
      throw parseContractError(error)
    }
  }

  /**
   * Calculate current yield for a deposit
   */
  async calculateYield(tokenId: bigint): Promise<bigint> {
    try {
      const result = await this.publicClient.readContract({
        address: this.address,
        abi: YieldVaultABI,
        functionName: 'calculateYield',
        args: [tokenId],
      })
      return result as bigint
    } catch (error) {
      throw parseContractError(error)
    }
  }

  /**
   * Check if a token has an active deposit
   */
  async hasActiveDeposit(tokenId: bigint): Promise<boolean> {
    const deposit = await this.getDeposit(tokenId)
    return deposit !== null && deposit.principal > 0n
  }

  // ==================== Write Methods ====================

  /**
   * Deposit an invoice to the vault
   * Requires wallet connection
   */
  async deposit(params: DepositParams): Promise<Hash> {
    if (!this.walletClient) {
      throw new Error('Wallet client required for write operations')
    }

    try {
      const { request } = await this.publicClient.simulateContract({
        address: this.address,
        abi: YieldVaultABI,
        functionName: 'deposit',
        args: [params.tokenId, params.strategy, params.principal],
        account: this.walletClient.account,
      })

      const hash = await this.walletClient.writeContract(request)
      return hash
    } catch (error) {
      throw parseContractError(error)
    }
  }

  /**
   * Withdraw a deposit from the vault
   * Requires wallet connection
   */
  async withdraw(tokenId: bigint): Promise<Hash> {
    if (!this.walletClient) {
      throw new Error('Wallet client required for write operations')
    }

    try {
      const { request } = await this.publicClient.simulateContract({
        address: this.address,
        abi: YieldVaultABI,
        functionName: 'withdraw',
        args: [tokenId],
        account: this.walletClient.account,
      })

      const hash = await this.walletClient.writeContract(request)
      return hash
    } catch (error) {
      throw parseContractError(error)
    }
  }

  /**
   * Change deposit strategy
   * Requires wallet connection
   */
  async changeStrategy(tokenId: bigint, newStrategy: Strategy): Promise<Hash> {
    if (!this.walletClient) {
      throw new Error('Wallet client required for write operations')
    }

    try {
      const { request } = await this.publicClient.simulateContract({
        address: this.address,
        abi: YieldVaultABI,
        functionName: 'changeStrategy',
        args: [tokenId, newStrategy],
        account: this.walletClient.account,
      })

      const hash = await this.walletClient.writeContract(request)
      return hash
    } catch (error) {
      throw parseContractError(error)
    }
  }

  // ==================== Utility Methods ====================

  /**
   * Get contract address
   */
  getAddress(): Address {
    return this.address
  }

  /**
   * Format APY from contract (basis points) to percentage
   * Contract returns basis points (e.g., 500 = 5.00%)
   */
  static formatAPY(apy: bigint): number {
    return Number(apy) / 100
  }

  /**
   * Get strategy name
   */
  static getStrategyName(strategy: Strategy): string {
    switch (strategy) {
      case Strategy.Hold:
        return 'Hold'
      case Strategy.Conservative:
        return 'Conservative'
      case Strategy.Aggressive:
        return 'Aggressive'
      default:
        return 'Unknown'
    }
  }

  /**
   * Get strategy description
   */
  static getStrategyDescription(strategy: Strategy): string {
    switch (strategy) {
      case Strategy.Hold:
        return 'Keep funds safe, no active yield generation'
      case Strategy.Conservative:
        return 'Moderate risk, stable returns'
      case Strategy.Aggressive:
        return 'Higher risk, maximize yield potential'
      default:
        return ''
    }
  }
}
